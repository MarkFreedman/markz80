// scripts/sync-albums.mjs
// Usage: node -r dotenv/config scripts/sync-albums.mjs

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import dotenv from "dotenv";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, "..", ".env.local") });

const CLIENT_ID = process.env.SPOTIFY_CLIENT_ID;
const CLIENT_SECRET = process.env.SPOTIFY_CLIENT_SECRET;

// Mark Z80 artist ID from your URL
const ARTIST_ID = "4SjGt5PGXEpyrqRyU6QsYg";

if (!CLIENT_ID || !CLIENT_SECRET) {
  console.error("Missing SPOTIFY_CLIENT_ID or SPOTIFY_CLIENT_SECRET in .env.local");
  process.exit(1);
}

async function getToken() {
  const creds = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString("base64");
  const res = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: {
      Authorization: `Basic ${creds}`,
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: new URLSearchParams({ grant_type: "client_credentials" }),
  });
  if (!res.ok) {
    const t = await res.text();
    throw new Error(`Token error: ${res.status} ${t}`);
  }
  const data = await res.json();
  return data.access_token;
}

async function fetchAllAlbums(token) {
  // Only full albums, exclude singles/compilations/appears_on
  // Weâ€™ll also dedupe by name (Spotify can return duplicates by market)
  let url = `https://api.spotify.com/v1/artists/${ARTIST_ID}/albums?include_groups=album&market=US&limit=50`;
  const albums = [];
  const seen = new Set();

  while (url) {
    const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
    if (!res.ok) {
      const t = await res.text();
      throw new Error(`Albums fetch error: ${res.status} ${t}`);
    }
    const data = await res.json();
    for (const a of data.items || []) {
      const key = `${a.name}::${a.release_date}`;
      if (seen.has(key)) continue;
      seen.add(key);
      albums.push(a);
    }
    url = data.next; // Spotify returns full URL for next page or null
  }
  return albums;
}

function toAlbumData(a) {
  // Pick the largest image (index 0 typically)
  const img = (a.images && a.images[0] && a.images[0].url) || "";
  return {
    slug: slugify(a.name),
    title: a.name,
    year: parseInt((a.release_date || "0000").slice(0, 4), 10),
    coverUrl: img,
    spotifyUrl: a.external_urls?.spotify || null,
    // Leave other platforms null for now; you can fill later if you want
    appleUrl: null,
    youtubeUrl: null,
    bandcampUrl: null,
  };
}

function slugify(str) {
  return String(str)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "");
}

function writeAlbumsTs(records) {
  const outPath = path.join(__dirname, "..", "app", "data", "albums.ts");
  const contents =
`// AUTO-GENERATED by scripts/sync-albums.mjs
// Do not edit by hand. Re-run the script to refresh from Spotify.

export type Album = {
  slug: string;
  title: string;
  year: number;
  coverUrl: string;
  spotifyUrl?: string | null;
  appleUrl?: string | null;
  youtubeUrl?: string | null;
  bandcampUrl?: string | null;
};

export const albums: Album[] = ${JSON.stringify(records, null, 2)};
`;
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, contents, "utf8");
  console.log(`Wrote ${records.length} albums to app/data/albums.ts`);
}

(async () => {
  try {
    const token = await getToken();
    const raw = await fetchAllAlbums(token);

    // Map to our simpler shape, sort newest first
    const data = raw.map(toAlbumData).sort((a, b) => b.year - a.year);

    writeAlbumsTs(data);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
